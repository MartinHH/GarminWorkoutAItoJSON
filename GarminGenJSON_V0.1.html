<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Garmin JSON Workout Generator</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 900px; margin: auto; padding: 1em; background: #f8f9fa; }
    textarea { width: 100%; height: 120px; font-family: monospace; font-size: 1rem; margin-bottom: 1em; }
    button { padding: 0.5em 1em; margin-right: 1em; font-size: 1rem; cursor: pointer; }
    pre { background: #fff; border: 1px solid #ccc; height: 400px; overflow: auto; padding: 1em; white-space: pre-wrap; word-break: break-word; font-family: monospace; }
    label { font-weight: bold; }
  </style>
</head>
<body>

<h1>Garmin JSON Workout Generator</h1>
<p>
  <b>Format example:</b> <br>
  <code>name,description;step1;step2;repeat(n)[stepA;stepB];...</code><br>
</p>

<textarea id="inputWorkout" spellcheck="false">
My Title,My Description;warmup(lap,1);warmup(time,700,1);repeat(2)[warmup(time,60,2);interval(distance,600,5)];recovery(time,2000,0)
</textarea>
<br>
<button id="generateBtn">Generate JSON</button>
<button id="downloadBtn" disabled>Download JSON</button>

<h2>Generated Garmin JSON:</h2>
<pre id="outputJson">The generated JSON will appear here.</pre>


<script>
 const garminTemplate = {
  workoutId: 931101353,
  ownerId: 118310919,
  workoutName: null,
  description: null,
  updatedDate: new Date().toISOString(),
  createdDate: new Date().toISOString(),
  sportType: {
    sportTypeId: 1,
    sportTypeKey: "running",
    displayOrder: 1
  },
  subSportType: "GENERIC",
  trainingPlanId: null,
  author: {
    userProfilePk: 118310919,
    displayName: "",
    fullName: "",
    profileImgNameLarge: null,
    profileImgNameMedium: "",
    profileImgNameSmall: "",
    userPro: false,
    vivokidUser: false
  },
  workoutSegments: [
    {
      segmentOrder: 1,
      sportType: {
        sportTypeId: 1,
        sportTypeKey: "running",
        displayOrder: 1
      },
      poolLengthUnit: null,
      poolLength: null,
      avgTrainingSpeed: null,
      estimatedDurationInSecs: null,
      estimatedDistanceInMeters: null,
      estimatedDistanceUnit: null,
      estimateType: null,
      description: null,
      workoutSteps: []
    }
  ],
  poolLength: null,
  poolLengthUnit: null,
  locale: null,
  workoutProvider: null,
  workoutSourceId: null,
  uploadTimestamp: null,
  atpPlanId: null,
  consumer: null,
  consumerName: null,
  consumerImageURL: null,
  consumerWebsiteURL: null,
  workoutNameI18nKey: null,
  descriptionI18nKey: null,
  avgTrainingSpeed: 2.59,
  estimateType: null,
  estimatedDistanceUnit: {
    unitId: null,
    unitKey: null,
    factor: null
  },
  workoutThumbnailUrl: null,
  isSessionTransitionEnabled: null,
  shared: false
};

const stepTypeMap = {
  warmup: { stepTypeId: 1, displayOrder: 1 },
  cooldown: { stepTypeId: 2, displayOrder: 2 },
  interval: { stepTypeId: 3, displayOrder: 3 },
  recovery: { stepTypeId: 4, displayOrder: 4 },
  repeat: { stepTypeId: 6, displayOrder: 6 }
};

const conditionTypeMap = {
  lap: { conditionTypeId: 1, conditionTypeKey: "lap.button", displayOrder: 1 },
  time: { conditionTypeId: 2, conditionTypeKey: "time", displayOrder: 2 },
  distance: { conditionTypeId: 3, conditionTypeKey: "distance", displayOrder: 3 },
  iterations: { conditionTypeId: 7, conditionTypeKey: "iterations", displayOrder: 7 }
};

const targetTypeMap = {
  "0": { workoutTargetTypeId: 1, workoutTargetTypeKey: "no.target", displayOrder: 1 },
  "null": { workoutTargetTypeId: 1, workoutTargetTypeKey: "no.target", displayOrder: 1 },
  "": { workoutTargetTypeId: 1, workoutTargetTypeKey: "no.target", displayOrder: 1 },
  "no": { workoutTargetTypeId: 1, workoutTargetTypeKey: "no.target", displayOrder: 1 },
  "1": { workoutTargetTypeId: 4, workoutTargetTypeKey: "heart.rate.zone", displayOrder: 4 },
  "2": { workoutTargetTypeId: 4, workoutTargetTypeKey: "heart.rate.zone", displayOrder: 4 },
  "3": { workoutTargetTypeId: 4, workoutTargetTypeKey: "heart.rate.zone", displayOrder: 4 },
  "4": { workoutTargetTypeId: 4, workoutTargetTypeKey: "heart.rate.zone", displayOrder: 4 },
  "5": { workoutTargetTypeId: 4, workoutTargetTypeKey: "heart.rate.zone", displayOrder: 4 }
};

let stepIdCounter = 7316001338;

// SOLUTION : Utilise splitSteps pour TOUT découper proprement !
// Elle gère les imbrications de crochets.
function splitSteps(str){
  const arr = [];
  let current = "", level = 0;
  for(let i=0;i<str.length;i++){
    const c = str[i];
    if(c === "[") level++;
    if(c === "]") level--;
    if(c === ";" && level===0){
      arr.push(current.trim());
      current="";
    } else {
      current+=c;
    }
  }
  if(current.trim()!=="") arr.push(current.trim());
  return arr;
}

function parseExecutableStep(stepStr, order, stepId) {
  const stepTypeRaw = stepStr.split("(")[0].trim().toLowerCase();
  const paramsMatch = stepStr.match(/\((.*)\)/);
  const params = paramsMatch ? paramsMatch[1].split(",").map(p => p.trim()) : [];

  const st = stepTypeMap[stepTypeRaw] || { stepTypeId: 0, displayOrder: 0 };
  const condKey = params[0] ? params[0].toLowerCase() : null;
  const cond = conditionTypeMap[condKey] || conditionTypeMap.lap;

  let endValue;
  if (cond.conditionTypeKey === "lap.button") {
    endValue = null;
  } else {
    endValue = params[1] === undefined || params[1] === "null" ? null : Number(params[1]);
  }

  let zoneRaw = params[2] === undefined ? null : params[2];
  const target = targetTypeMap[zoneRaw === null ? "null" : zoneRaw.toString()] || targetTypeMap["0"];

  let unitPref = null;
  if (cond.conditionTypeKey === "distance") {
    unitPref = { unitId: 1, unitKey: "meter", factor: 100 };
  }

  return {
    type: "ExecutableStepDTO",
    stepId: stepId,
    stepOrder: order,
    stepType: {
      stepTypeId: st.stepTypeId,
      stepTypeKey: stepTypeRaw,
      displayOrder: st.displayOrder
    },
    childStepId: null,
    description: null,
    endCondition: {
      conditionTypeId: cond.conditionTypeId,
      conditionTypeKey: cond.conditionTypeKey,
      displayOrder: cond.displayOrder,
      displayable: true
    },
    endConditionValue: endValue,
    preferredEndConditionUnit: unitPref,
    endConditionCompare: null,
    targetType: {
      workoutTargetTypeId: target.workoutTargetTypeId,
      workoutTargetTypeKey: target.workoutTargetTypeKey,
      displayOrder: target.displayOrder
    },
    targetValueOne: null,
    targetValueTwo: null,
    targetValueUnit: null,
    zoneNumber: target.workoutTargetTypeKey === "heart.rate.zone" ? (zoneRaw ? Number(zoneRaw) : null) : null,
    secondaryTargetType: null,
    secondaryTargetValueOne: null,
    secondaryTargetValueTwo: null,
    secondaryTargetValueUnit: null,
    secondaryZoneNumber: null,
    endConditionZone: null,
    strokeType: {
      strokeTypeId: 0,
      strokeTypeKey: null,
      displayOrder: 0
    },
    equipmentType: {
      equipmentTypeId: 0,
      equipmentTypeKey: null,
      displayOrder: 0
    },
    category: null,
    exerciseName: null,
    workoutProvider: null,
    providerExerciseSourceId: null,
    weightValue: null,
    weightUnit: {
      unitId: 8,
      unitKey: "kilogram",
      factor: 1000
    }
  };
}

function parseSteps(stepsArr, orderStart = 1) {
  let steps = [];
  let order = orderStart;
  let localStepId = stepIdCounter;
  for (const stepStr of stepsArr) {
    const repeatMatch = stepStr.match(/^repeat\((\d+)\)\[(.*)\]$/i);
    if (repeatMatch) {
      const iters = Number(repeatMatch[1]);
      const innerStr = repeatMatch[2];
      const innerStepsArr = splitSteps(innerStr);
      stepIdCounter++; // 1 pour le repeatGroup
      const innerSteps = parseSteps(innerStepsArr, 1);
      const repeatGroup = {
        type: "RepeatGroupDTO",
        stepId: localStepId++,
        stepOrder: order++,
        stepType: {
          stepTypeId: stepTypeMap.repeat.stepTypeId,
          stepTypeKey: "repeat",
          displayOrder: stepTypeMap.repeat.displayOrder
        },
        childStepId: 1,
        numberOfIterations: iters,
        workoutSteps: innerSteps,
        endConditionValue: iters,
        preferredEndConditionUnit: null,
        endConditionCompare: null,
        endCondition: {
          conditionTypeId: conditionTypeMap.iterations.conditionTypeId,
          conditionTypeKey: conditionTypeMap.iterations.conditionTypeKey,
          displayOrder: conditionTypeMap.iterations.displayOrder,
          displayable: false
        },
        skipLastRestStep: null,
        smartRepeat: false
      };
      steps.push(repeatGroup);
    } else {
      steps.push(parseExecutableStep(stepStr, order++, localStepId++));
    }
  }
  stepIdCounter = localStepId;
  return steps;
}

function randomIntString(length) {
  let s = Math.floor(Math.random() * 9 + 1).toString();
  while (s.length < length) s += Math.floor(Math.random() * 10);
  return s;
}

function parseWorkoutString(input) {
  stepIdCounter = 7316001338;
  const parts = splitSteps(input);
  if (parts.length < 2) throw new Error("Invalid format: must have title, description, and at least one step.");
  const [titleDesc, ...stepsRaw] = parts;
  const [title, description] = titleDesc.split(",");

  const workout = JSON.parse(JSON.stringify(garminTemplate));

  // Numéros uniques à chaque export :
  const ownerId = parseInt(randomIntString(9), 10);
  const userProfilePk = parseInt(randomIntString(9), 10);
  const workoutId = parseInt(randomIntString(10), 10);

  workout.workoutName = (title || "No title") + " - " + new Date().toLocaleString("sv-SE");
  workout.description = (description ? description.trim() : "") + " - Exported at " + new Date().toISOString();
  workout.ownerId = ownerId;
  workout.workoutId = workoutId;
  workout.author.userProfilePk = userProfilePk;

  workout.workoutSegments[0].workoutSteps = parseSteps(stepsRaw);
  return workout;
}

  // Gestion UI
  const inputEl = document.getElementById("inputWorkout");
  const outputEl = document.getElementById("outputJson");
  const generateBtn = document.getElementById("generateBtn");
  const downloadBtn = document.getElementById("downloadBtn");

  let lastJson = null;

  generateBtn.addEventListener("click", () => {
    try {
      const inputText = inputEl.value.trim();
      if (!inputText) {
        outputEl.textContent = "Veuillez entrer une chaîne d'entraînement.";
        downloadBtn.disabled = true;
        return;
      }
      const jsonResult = parseWorkoutString(inputText);
      lastJson = JSON.stringify(jsonResult, null, 2);
      outputEl.textContent = lastJson;
      downloadBtn.disabled = false;
    } catch (e) {
      outputEl.textContent = "Erreur : " + e.message;
      downloadBtn.disabled = true;
    }
  });

  downloadBtn.addEventListener("click", () => {
  if (!lastJson) return;
  // Récupère le nom du workout pour le nom de fichier
  let workoutName = "garmin_workout";
  try {
    const obj = JSON.parse(lastJson);
    workoutName = obj.workoutName
      ? obj.workoutName.replace(/[^\w\-]+/g,"_")           // on remplace les caractères spéciaux et espaces
      : "garmin_workout";
  } catch(e) {} // fallback si parse crash

  const blob = new Blob([lastJson], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = workoutName + ".json";
  a.click();
  URL.revokeObjectURL(url);
});
</script>

</body>
</html>